\chapter{Preprocessor integrations}

It is very common for web applications to depends on one or multiple preprocssing tools which can
perform many different things. For example, one can consider TypeScript compiler a code preprocessor
which compiles TypeScript code to JavaScript. One of the most notorious code preprocessors is Babel,
which takes a modern JavaScript code and transpiles it into older versions that are compatible with
a wide range of browsers. However, the biggest group of code preprocessors are bundlers which
combine multiple preprocessors and tolls to simplify developer experience by providing hot
reloading, debugging and source map support.

These tools are essential for web application developers and they are configured declaratively and
abstracted away from the application authors. Unfortunately, these tools might produce a non Trusted
Types compliant code. To achieve Trusted Types compliance in frameworks and applications, one must
ensure that the code preprocessing tools are Trusted Types compliant or implement the Trusted Types
integration.

\section{Compliant preprocessors}

There are a lot of preprocessors which do not affect the Trusted Type compliance of a code. It is
hard to formally define this group, but these are usually the code transformations which do not
change the semantics of the code. For example:

\begin{itemize}
  \item TypeScript -- TypeScript compiler transforms the TypeScript sources to equivalent code
        written in JavaScript by mostly removing the type annotations. Such transformations yields
        semantically equivalent code.
  \item Transformation to older JavaScript standard -- One of the most common functionality of Babel
        is to transpile code written in modern JavaScript language to older standard compatible with
        wide range of browsers and browser versions. Many of these transformations are solved with
        polyfills or simple AST replacements but the code remains semantically the same.
  \item Minification and obfuscation -- The purpose of the code minification is to reduce the
        overall bundle size that needs to be sent by the server to the clients browser. In practice
        this includes removing dead code, changing the names of the functions, shortening
        expressions and statements, however the minified code is functionally equivalent to the non
        minified one.
\end{itemize}

There are many examples of harmless preprocessors in the context of Trusted Types compliant
applications and libraries. All of these work with Trusted Types out of the box. Unfortunately,
there are tools and preprocessors which produce non Trusted Types compliant code for which a Trusted
Types integration is needed.

\section{Babel}

Babel is an extremely large collection of tools and plugins. For this paper the most interesting
feature of Babel is JSX transformation. JSX is an XML-like syntax extension to ECMAScript without
any defined semantics. It is not intended to be used by preprocessors to transform the JSX markup
into standard JavaScript.

The JSX was originally designed to simplify the syntax for React applications. However, the
specification \cite{jsx_spec} is generic and can be used for multiple use cases and not only UI
related.

One of these non React JSX use case it the JSX preprocessing inside solid.js framework (TODO:
reference). This framework resembles React as it is component oriented, uses the JSX to write
component code and supports native APIs which resemble the hooks API from React. The important fact
is that under the hood the translated JSX is very different. React translates the JSX to
\text{React.createElement} calls but solid translates the JSX markup to native HTML templates. The
frameworks differences are not that important for this paper. However, both of them use Babel JSX
preprocessor to transform the easier to read JSX to JavaScript compatible code.

The Solid.js preprocessor internally uses \textit{HTMLTemplateElement.innerHTML} attribute when
creating the template. This triggers a Trusted Types violation when the code is executed in the
browser. The solution is to create a Trusted Types policy wrapping the content assigned to innerHTML
property. This is safe, because the JSX transformation only creates the templates from statically
known HTML. All dynamic and interpolated markup is rendered using JavaScript without using any
dangerous sinks.

% TODO: Add examples of generated babel markup

\section{Bundlers}

Bundlers deal with many different tasks such as code minification and obfuscation, loading different
file types, bundling all of the source files into big chunks, hot reloading in development and more.

Many of the bundler responsibilities are Trusted Types compliant out of the box, however many of the
development only features break when Trusted Types are enforced. Usually bundlers include a
development server which injects some markup into DOM to provide better developer experience for the
application authors. Common examples include hot reloading changed parts of the application or
showing error overlay widget.

Fortunately, Trusted Types are already supported in Webpack (starting from version 5), which is the
most used bundler at time of writing. However, there are some new promising ones which provide
better performance or use ES modules which leads to simpler architecture and more performant design.

\subsection{Vite}

Vite is one of the modern bundlers which serves the source files via native ES modules which have
many built in features and extremely fast and reliable hot module replacement (HMR) for development.
It also provides a simple way to bundle production code using another common bundler called Rollup.

Vite is especially interesting to us in this paper, because it is a preferred bundler for creating
applications using solid.js framework. To
support development of solid applications, we needed to create a Trusted Types integration for Vite.

We followed the integration process from chapter (\ref{tt_integration_setup}) and have identified
three places which cause Trusted Types violations. These can be categorized into:

\begin{itemize}
  \item Creation of style elements -- Internally, Vite used \textit{innerHTML} of an HTML style
        element to create apply styles to the DOM. These two occurrences can be replaced with a safer
        alternative using \textit{textContent} which does not trigger a Trusted Types violation, but works
        for CSS stylesheet creation.

        \bigskip
        \begin{lstlisting}[language=JavaScript, caption=Creation of style elements using innerHTML in Vite \cite{commit_vite_inner_html_styles}]
if (!style) {
  style = document.createElement('style')
  style.setAttribute('type', 'text/css')
  style.innerHTML = content
  document.head.appendChild(style)
} else {
  style.innerHTML = content
}
\end{lstlisting}

  \item Showing error overlay -- Vite supports HMR during development and part of this feature is
        error overlay feature when there is an error triggered by the development server. This
        usually happens when there is an syntax error in the code. The overlay widget uses
        \textit{innerHTML} property to inject the overlay HTML markup into the clients web page. The
        solution in this case was to introduce a Trusted Types policy to wrap the overlay code
        inside Trusted Types policy. Alternative solution would be to to create the overlay markup
        dynamically using \textit{document.createElement}.

        In the future, the Trusted Types API might provide support from constructing trusted values
        from string constants via template literals, but this is not yet supported.

        \bigskip
        \begin{lstlisting}[language=JavaScript, caption=Creation of error overlay using innerHTML property \cite{commit_vite_inner_html_overlay}]
export class ErrorOverlay extends HTMLElement {
  root: ShadowRoot

  constructor(err: ErrorPayload['err']) {
    super()
    this.root = this.attachShadow({ mode: 'open' })
    this.root.innerHTML = template
    (further lines omitted for brevity...)
\end{lstlisting}

        \bigskip
        \begin{lstlisting}[language=JavaScript, caption=Creation of error overlay using Trusted Types policy \cite{commit_vite_policy_overlay}]
export class ErrorOverlay extends HTMLElement {
  root: ShadowRoot

  constructor(err: ErrorPayload['err']) {
    super()

    let policy
    if (window.trustedTypes) {
      policy = window.trustedTypes.createPolicy('vite-overlay', {
        createHTML: (s) => s
      })
    }

    this.root = this.attachShadow({ mode: 'open' })
    this.root.innerHTML = policy
      ? (policy.createHTML(template) as any)
      : template
    (further lines omitted for brevity...)
\end{lstlisting}


\end{itemize}
