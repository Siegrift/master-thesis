\chapter{Integrations into web frameworks and libraries}

In this chapter we describe integrations to web applications and libraries we implemented. We
document each unique properties of the integration, sinks found and the respective solutions.

\section{Create React App integration}

Create React App (CRA) (described in \ref{intro-cra}) was a second project we wanted to integrate
Trusted Types to. After taking a look in the implementation of CRA we found that this tool does not
depend on React directly, but only installs it after creating the project template. Our goal shifted
to make sure the generated project by CRA is Trusted Types compatible.

\subsection{Using Trusted Types compatible version of React}

To accomplish this, we would need to change the implementation of CRA to install Trusted Types
compatible version of React. Unfortunately, such version of React is implemented under a feature
flag which needs to be turned on at build time. The published version of React contains the already
built files with the feature flag turned off. This means that if you want to use the Trusted Types
compatible version of React you have to clone the React repository from sources, turn on the feature
flag and then build the framework. You can then use this version of React as a dependency in your
project generated by CRA.

Implementing this is non trivial, since it requires knowledge about React. More importantly though,
this is harder to maintain for the application authors since you need to keep up with the new
releases of React manually.

\subsection{Using Trusted Types compliant version of Webpack}

CRA internally uses webpack version 5 to provide fast development experience with convenient
features, such as hot reload. It also bundles the application for production and it handles
minification and other optimizations. Some of these features, especially hot reload breaks under
Trusted Types in enforcement mode. Gladly, webpack can be configured to be Trusted Types compliant
by a small configuration change \cite{webpack_tt_config}.

The problem with CRA is that the webpack configuration is abstracted away from the user. This means
that there is not a simple way how to enable the Trusted Types integration. One can find the webpack
configuration in the downloaded dependencies and change it there directly, but this won't really
work since those changes will be removed by the package manager when modifying the dependencies. In
general, one should never modify the contents of dependencies and treat it only as read only inputs
to the program.

The optimal solution as of now is to use a workaround which allows you to spy on modules and change
what they return. This pattern is often used when mocking or spying in unit tests. However, it is
also a suitable solution for this case \cite{cra_modify_webpack_config}. CRA team is reluctant to
change this, since the hidden configuration is a good default for the majority of users.

\bigskip
\begin{lstlisting}[language=JavaScript, caption=Script to start React application with Trusted Types enabled in webpack]
// File 'scripts/start.js'
const rewire = require('rewire')
const defaults = rewire('react-scripts/scripts/start.js')
const webpackConfig = require('react-scripts/config/webpack.config')

// In order to override the webpack configuration without ejecting the create-react-app
defaults.__set__('configFactory', (webpackEnv) => {
  let config = webpackConfig(webpackEnv)

  // Customize the webpack configuration here, for reference I have updated webpack externals field
  config.output.trustedTypes = {
    policyName: 'webpack-policy',
  }

  return config
})
\end{lstlisting}

The application is then started simply by running this script using node.

\bigskip
\begin{lstlisting}[language=JavaScript, caption=Running the application]
node ./scripts/start
\end{lstlisting}

Another option is to use the \textit{eject} command from CRA. This is a one way operation and it
essentially unwraps all of the hidden configuration and creates these files in your project. You can
then simply edit the webpack configuration which is now part of your project. This is not
recommended and it should be used only when all other attempts fail. The generated webpack
configuration is pretty complex and updating it in the future might not be trivial.

\section{Next.js integration}

Next.js (described in \ref{intro-nextjs}) was the initial choice for Trusted Types integration,
because of the large impact this integration would have. The framework itself seemed interested in
the integration of Trusted Types for a longer time \cite{nextjs_tt_pr_2020}.

We forked the Next.js repository and created a basic Next.js application. We then used the local
version of Next.js as a dependency for our application. The integration required a few code changes
in the implementation of Next.js and we ended up with a working version which supported the
application in dev mode with Trusted Types under enforcement mode. We managed to accomplish this
with one simply Trusted Types policy in a couple of days.

\bigskip
\begin{lstlisting}[language=JavaScript, caption=Example of Next.js Trusted Types API]
let policy;

const whitelistAll = (str) => str;

// The policy getter is a private part of the module
// and cannot be used directly.
const getOrCreatePolicy = () => {
  if (policy) return policy;

  policy = window.trustedTypes?.createPolicy('next', {
    createHTML: whitelistAll('createHTML'),
    createScript: whitelistAll('createScript'),
    createScriptURL: whitelistAll('createScriptURL'),
  });
  return policy;
};

export const __unsafeAllowHtml = (html) => getOrCreatePolicy()?.createHTML(html) ?? html;

export const __unsafeAllowScriptUrl = (scriptUrl) => getOrCreatePolicy()?.createScriptURL(scriptUrl) ?? scriptUrl;

export const __unsafeAllowScript = (script) => getOrCreatePolicy()?.createScript(script) ?? script;
\end{lstlisting}

The fixes needed were small the Trusted Types API specific for Next.js was encapsulated in a single
small module. That said, the implementation was only a proof of concept and the policy implemented
might have allowed more then necessary. However, we decided not to pursue this project no more due
to different priorities and shifted focus to a different project.

\subsection{Fixing violations reported by Tsec}

Tsec found 8 violations \cite{tsec_output} inside Next.js sources. Out of these 7 were indeed
Trusted Types violations that needed to be fixed. Some of these could be fixed simply on a type
system level since they expected a value from the user. The others needed to be allowed explicitely
by using a policy. The implementation for this proof of concept can be found on github
\cite{nextjs_fix_tsec_violations_commit}.

Since our utmost goal was to find the sinks and create a prototype for the integration we wrapped
all of these values in Trusted Types objects. This was to be revisited in the future.

\subsection{Fixing the dev mode of an example application}

Fixing the violations found by Tsec was not enough and the application still wouldn't launch with
Trusted Types enforced. The reason for this hasn't been clear, but it was probably a webpack plugin
used in one of the Next.js dependencies. The violating code relied on eval, which threw an error
when Trusted Types were enforced. The workaround for this was to use a default policy and allow all
eval calls.

Apart from this, there was another violation that was triggered caused by application hot reloading
(\ref{def:hot_reload}). Tsec wasn't able to catch this, since the violation came from a JavaScript
file where the AST information was limited.

% TODO: vite
% - in development need to allow duplicate
% - which is one of the newest UI libraries and showed how 

% TODO: web apps
% - move description from chapter 1 to this chapter to make it bigger
